<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stars</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <canvas class="myCanvas">
        <p>Add suitable fallback here.</p>
    </canvas>
    <script>

        const canvas = document.querySelector('.myCanvas');
        const cwidth = canvas.width = window.innerWidth;
        const cheight = canvas.height = window.innerHeight;

        var eventq = 0;
        document.addEventListener('keydown', function (event) {
            eventq = event.keyCode;
        });

        var Tschioo = new Audio('Tschioo.mp3');
        var Prrt = new Audio('Prrt.mp3');
        var Bouff = new Audio('Bouff.mp3');
        var Flick = new Audio('Flick.mp3');
        var Swoosh = new Audio('Swoosh.mp3');
        var Dioomm = new Audio('Dioomm.mp3');
        var Tetris = new Audio('stars theme.mp3');
        Tetris.volume = 0.0;

        // my classes
        class RAtype {
            constructor(h = 3, dm = 4) {
                this.h = h;  // [0..23] increases when moving left
                this.dm = dm;  // 10th of a minute
            }
        }
        class DEtype {
            constructor(d = 3, m = 4) {
                this.d = d;    // [-90..90] positive is north, negative is south
                this.m = m;
            }
        }
        class RADEtype {
            constructor(h = 3, dm = 4, d = 5, m = 6) {
                this.h = h;  // increases when moving left
                this.dm = dm;  // 10th of a minute
                this.d = d;    // positive is north, negative is south
                this.m = m;
            }
            toString(name = 'RADE') {
                let s = name + '(RA=' + this.h.toFixed(2) + ', dm=' + this.dm.toFixed(2) + ', DE=' + this.d.toFixed(2) + ', m=' + this.m.toFixed(2) + ')';
                return s;

            }
            toV3D() {
                let a = new V3Dtype(0, 0, );
                let ra = this.h / 24 * 2 * Math.PI + this.dm / 600;
                let de = (this.d + this.m / 60) / 360 * 2 * Math.PI;
                let r = Math.cos(de);
                a.z = Math.sin(de);
                a.x = r * Math.cos(ra);
                a.y = r * Math.sin(ra);
                return a;
            }
        }
        class STARtype {
            constructor(name = "unknown", HD = "-", BD = "BD-", h = 3, dm = 4, d = 5, m = 6, Ptm = 0, SpT = "G2") {
                this.name = name;
                this.HD = HD;
                this.BD = BD;
                this.h = h;  // increases when moving left
                this.dm = dm;  // 10th of a minute
                this.d = d;    // positive is north, negative is south
                this.m = m;
                this.Ptm = Ptm;
                this.SpT = SpT;
            }
        }
        class V3Dtype {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            mul(f) {
                this.x *= f;
                this.y *= f;
                this.z *= f;
            }
            copy(a) {
                this.x = a.x;
                this.y = a.y;
                this.z = a.z;
            }
            clone(a) {
                return new V3Dtype(this.x, this.y, this.z);
            }
            xproduct(b) {
                let result = new V3Dtype(this.y*b.z - this.z*b.y, this.z*b.x - this.x*b.z, this.x*b.y-this.y*b.x);
                return result;
            }
            abs() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
            sproduct(a) {
                return this.x * a.x + this.y * a.y + this.z * a.z;
            }
            subtract(a) {
                this.x -= a.x;
                this.y -= a.y;
                this.z -= a.z;
            }
            add(a) {
                this.x += a.x;
                this.y += a.y;
                this.z += a.z;
            }
            angle(v) {
                // angle between this and v
                return Math.acos(this.sproduct(v) / this.abs() / v.abs());
            }
            toString(name = 'V3D') {
                let s = name + '(' + this.x.toFixed(2) + ', ' + this.y.toFixed(2) + ', ' + this.z.toFixed(2) + ')';
                return s;

            }
        }
        class NAtype {
            // Hesse normal form. Can be a plane or a line
            // plane: n (x-a) = 0
            // line: x(l) = l*n + a
            constructor(n, a) {
                this.n = n;   // nota: |n| = 1
                this.a = a;   // a point in the plane / line 
            }
            toString(name = 'NAtype') {
                let s = name + '[n=' + this.n.toString() + ', ' + this.a.toString() + ']';
                return s;

            }
            distance(q) {
                // plane: distance to point 
                // with sign: positive if the point is in the direction of the normal vector n
                //let delta = new V3Dtype;
                //delta.copy(this.a);
                let delta = this.a.clone();
                delta.subtract(q);
                return delta.sproduct(this.n);
            }
            x(l) {
                // line: a point on the line where distance between a and x is l
                let x = this.n.clone();
                x.mul(l);
                x.add(this.a);
                return x;
            }
            intersection_point(line) {
                let cos_g = this.n.sproduct(line.n) / 1 / 1;
                let a = this.a.clone();
                a.subtract(line.a);
                let l = this.n.sproduct(a) / cos_g;
                return line.x(l);
            }
        }
        // the stars
        var stars = [];
        stars.push(new STARtype("Sirius", "48915", "BD-16 1591", 6, 407, -16, -35, -1.58, "A0"));
        stars.push(new STARtype("Rigel", "34085", "BD-08 1063", 5, 97, -8, -19, 0.34, "B8p"));
        // point of view
        var ego = new RADEtype(0, 0, 0, 0);
        var egoP = new RADEtype(0, 0, 90, 0);

        function RADEtoV3D(rade) {
            let a = new V3Dtype;
            //r = cos();
            return a;
        }
        function draw_star(ctx, color, mag, x, y) {
            mag = Math.exp(1 - mag);
            // fill with background color
            ctx.fillStyle = color;
            //ctx.fillRect(x, y, 10, 10);
            ctx.beginPath();
            ctx.arc(x, y, mag, 0, 2 * Math.PI);
            ctx.fill();
        }
        function draw_field(ctx) {
            // fill with background color
            ctx.fillStyle = 'rgb(5, 5, 25)';
            ctx.fillRect(0, 0, cwidth, cheight);
            // text
            ctx.fillStyle = 'blue';
            ctx.font = '24px georgia';
            let e = ego.toV3D();
            let eP = egoP.toV3D();
            let p0x = new NAtype(e.xproduct(eP), e);
            let screen = new NAtype(e, e);
            //e.mul(.5);
            ctx.fillText(ego.toString('Ego') + ', '
                + e.toString('e') + ', ' + eP.toString('eP') + ', ' + p0x.toString('p0x'),
                0, 50);
            /*
            ctx.fillText('Distance= ' + screen.distance(e).toFixed(2), 0, 100);
            ctx.fillText('Angle= ' + e.angle(new V3Dtype(1, 0, 0)), 0, 120);
            //ctx.fillText('Ego: (' + e.x.toString() + ', ' + egoDE.m.toString() + ', SpT=' + stars[1].SpT.toString(), 100, 400);
            */
            // draw equator
            for (let i = 0; i < 24; ++i) {
                let i1 = new RADEtype(i, 0, 0, 0);
                let i11 = i1.toV3D();
                let g = i11.angle(screen.n);
                if (Math.abs(g) >= Math.PI / 2) continue;
                let sx = Math.sin(g) / Math.sin(Math.PI / 2 - g);
                let d = 1;
                if (g != 0) d = sx / Math.sin(g);
                let s = i11.clone();
                s.mul(d);  // 
                s2 = screen.intersection_point(new NAtype(i11, new V3Dtype(0, 0, 0)));
                s2x = p0x.distance(s2);
                //s.subtract(screen.a);
                ctx.fillStyle = 'blue';
                ctx.fillText('RA=' + i
                    + ' => sx= ' + sx.toFixed(2)
                    + ' => d= ' + d.toFixed(2)
                    + ', angle gamma=' + g.toFixed(2)
                    + ', s=' + s.toString()
                    + ', s2=' + s2.toString()
                    + ', s2x=' + s2x.toFixed(2)
                    , 0, i * 20 + 150);
                e = RADEtoV3D(ego);
                let mag = 0;
                if (i == 0) mag = -1;
                draw_star(ctx, 'yellow', mag, cwidth / 2 + s2x / 4 * cwidth / 2, cheight / 2);
            }
            // draw zero meridian
            for (let i = 0; i < 24; ++i) {
                let i1 = new RADEtype(0, 0, i*15, 0);
                let i11 = i1.toV3D();
                let g = i11.angle(screen.n);
                if (Math.abs(g) >= Math.PI / 2) continue;
                let sx = Math.sin(g) / Math.sin(Math.PI / 2 - g);
                let d = 1;
                if (g != 0) d = sx / Math.sin(g);
                let s = i11.clone();
                s.mul(d);
                s.subtract(screen.a);
                ctx.fillStyle = 'blue';
                /*
                ctx.fillText('RA=' + i
                    + ' => sx= ' + sx.toFixed(2)
                    + ' => d= ' + d.toFixed(2)
                    + ', angle gamma=' + g.toFixed(2)
                    + ', s=' + s.toString()
                    , 0, i * 20 + 150);
                    */
                e = RADEtoV3D(ego);
                let mag = 0;
                if (i == 0) mag = -1;
                //draw_star(ctx, 'yellow', mag, cwidth / 2 + s.y / 4 * cwidth / 2, cheight / 2 + s.z / 4 *cwidth / 2);
            }
            // draw ecliptic
            // draw stars
        }

        const st_insertcoin = 0;
        const st_playing = 1;
        const st_gameover = 2;
        var status = st_insertcoin;
        function loop() {
            const ctx = canvas.getContext('2d');
            //console.log('status ' + status + ' event ' + eventq + ' c_part ' + c_part + ' c_height ' + c_height);
            if (status == st_insertcoin) {
                //process event:
                switch (eventq) {
                    case 32:
                    case 13:
                        Tetris.play();
                        status = st_playing;
                        break;
                }
                eventq = 0;
                // fill with background color
                ctx.fillStyle = 'rgb(5, 5, 25)';
                ctx.fillRect(0, 0, cwidth, cheight);
                // text
                ctx.fillStyle = 'blue';
                ctx.font = '128px georgia';
                ctx.fillText('STARS', 100, 100);
                ctx.font = '48px georgia';
                ctx.fillText('Press SPACE to start', 100, 200);
            }
            else if (status == st_gameover) {
                //process event:
                switch (eventq) {
                    case 32:
                    case 13:
                        Flick.play();
                        status = st_insertcoin;
                        break;
                }
                eventq = 0;
                // fill with background color
                ctx.fillStyle = 'rgb(255, 255, 255)';
                ctx.fillRect(0, 0, cwidth, cheight);
                // draw
                draw_field(ctx);
                // text
                ctx.fillStyle = 'red';
                ctx.font = '64px georgia bold';
                ctx.fillText('GAME OVER', getox(0), getoy(height / 2 - 2));
                ctx.font = '48px georgia';
                ctx.fillText('Press SPACE', getox(0), getoy(height / 2));
            }
            else if (status == st_playing) {
                //process event:
                switch (eventq) {
                    case 37:
                        //left
                        ego.h = (ego.h + 1) % 24;
                        break;
                    case 39:
                        //right
                        ego.h = (ego.h + 23) % 24;
                        break;
                    case 38:
                        //up
                        break;
                    case 32:
                        //space
                }
                eventq = 0;
                // draw
                draw_field(ctx);
            }
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>