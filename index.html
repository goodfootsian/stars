<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stars</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <canvas class="myCanvas">
        <p>Add suitable fallback here.</p>
    </canvas>
    <script src="star_class.js"></script>
    <script src="hip_db.js"></script>
    <script>

        const canvas = document.querySelector('.myCanvas');
        const cwidth = canvas.width = window.innerWidth;
        const cheight = canvas.height = window.innerHeight;

        var eventq = 0;
        document.addEventListener('keydown', function (event) {
            eventq = event.keyCode;
        });
        //
        var text2 = document.createElement('div');
        text2.style.position = 'absolute';
        text2.style.top = 10 + 'px';
        text2.style.left = 10 + 'px';
        text2.style.width = 100;
        text2.style.height = 200;
        text2.style.fontSize = "12px";
        text2.style.color = "#303080";
        text2.style.backgroundColor = "#00000000";
        text2.innerHTML = ""
        document.body.appendChild(text2);

        // touch events
        canvas.addEventListener("touchstart", handleStart);
        canvas.addEventListener("touchend", handleEnd);
        canvas.addEventListener("touchcancel", handleCancel);
        canvas.addEventListener("touchmove", handleMove);

        function handleStart() { }
        function handleEnd() { }
        function handleCancel() { }
        function handleMove() { }

        // mouse events
        canvas.addEventListener("click", mouseClick);

        function mouseClick(evt) {
            console.log('click ' + evt.pageX.toFixed(0) + ', ' + evt.pageY.toFixed(0));
        }

        var Tschioo = new Audio('Tschioo.mp3');
        var Prrt = new Audio('Prrt.mp3');
        var Bouff = new Audio('Bouff.mp3');
        var Flick = new Audio('Flick.mp3');
        var Swoosh = new Audio('Swoosh.mp3');
        var Dioomm = new Audio('Dioomm.mp3');
        var Tetris = new Audio('stars theme.mp3');
        Tetris.volume = 0.0;

        // my classes
        class RAtype {
            constructor(h = 3, dm = 4) {
                this.h = h;  // [0..23] increases when moving left / east
                this.dm = dm;  // 10th of a minute
            }
        }
        class DEtype {
            constructor(d = 3, m = 4) {
                this.d = d;    // [-90..90] positive is north, negative is south
                this.m = m;
            }
        }
        class SCREENtype {
            constructor(na, cwidth, cheight, magnification) {
                this.na = na;
                this.cwidth = cwidth;
                this.cheight = cheight;
                this.magnification = magnification;
            }
            toV3D(x, y) {
                return new V3Dtype();
            }
            toXY() {
                return new V3Dtype();
            }
        }

        class RADEtype {
            constructor(h = 0, dm = 0, d = 0, m = 0) {
                this.h = h;  // increases when moving left
                this.dm = dm;  // 10th of a minute
                this.d = d;    // positive is north, negative is south
                this.m = m;
            }
            toString(name = 'RADE') {
                let s = name + '(RA=' + this.h.toFixed(2) + ', dm=' + this.dm.toFixed(2) + ', DE=' + this.d.toFixed(2) + ', m=' + this.m.toFixed(2) + ')';
                return s;
            }
            toV3D() {
                let a = new V3Dtype(0, 0,);
                let ra = (this.h + this.dm / 600) / 24 * 2 * Math.PI;
                let de = (this.d) / 360 * 2 * Math.PI;
                let de_mdec = (this.m / 60) / 360 * 2 * Math.PI;
                if (de < 0) {
                    de -= de_mdec;
                } else {
                    de += de_mdec;
                }
                let r = Math.cos(de);
                a.z = Math.sin(de);
                a.x = r * Math.cos(ra);
                a.y = r * Math.sin(ra);
                return a;
            }
        }
        class V3Dtype {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            toRADE() {
                let rade = new RADEtype();
                // DE
                let zplane = new NAtype(new V3Dtype(0, 0, 1), new V3Dtype(0, 0, 0));
                let d = zplane.distance(this);
                if (d < -1) {
                    rade.d = 90;
                } else if (d > 1) {
                    rade.d = -90;
                } else { 
                    rade.d = -Math.asin(d) / Math.PI * 180;
                }
                //console.log(rade.d.toFixed(2) + " = ");
                let dtrunc = Math.trunc(rade.d);
                let dfrac = Math.abs(rade.d - dtrunc);
                rade.d = dtrunc;
                rade.m = dfrac * 60;
                //console.log(rade.d.toFixed(2) + " deg, " + rade.m.toFixed(2) + " minutes");
                // RA
                let a = 0;
                if (this.x > 0) {
                    a = Math.atan(this.y / this.x) / Math.PI * 180;
                } else if (this.x < 0 && this.y >= 0) {
                    a = Math.atan(this.y / this.x) / Math.PI * 180 + 180;
                } else if (this.x < 0 && this.y < 0) {
                    a = Math.atan(this.y / this.x) / Math.PI * 180 - 180;
                } else if (this.x == 0 && this.y > 0) {
                    a = 90;
                } else if (this.x == 0 && this.y < 0) {
                    a = -90;
                }
                if (a < 0) a += 360;
                rade.h = a / 15;
                rade.dm = rade.h;
                rade.h = Math.trunc(rade.h);
                rade.dm -= rade.h;
                rade.dm *= 600;
                return rade;
            }
            mul(f) {
                this.x *= f;
                this.y *= f;
                this.z *= f;
            }
            copy(a) {
                this.x = a.x;
                this.y = a.y;
                this.z = a.z;
            }
            clone(a) {
                return new V3Dtype(this.x, this.y, this.z);
            }
            xproduct(b) {
                let result = new V3Dtype(this.y * b.z - this.z * b.y, this.z * b.x - this.x * b.z, this.x * b.y - this.y * b.x);
                return result;
            }
            abs() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
            sproduct(a) {
                return this.x * a.x + this.y * a.y + this.z * a.z;
            }
            subtract(a) {
                this.x -= a.x;
                this.y -= a.y;
                this.z -= a.z;
            }
            add(a) {
                this.x += a.x;
                this.y += a.y;
                this.z += a.z;
            }
            angle(v) {
                // angle between this and v
                return Math.acos(this.sproduct(v) / this.abs() / v.abs());
            }
            toString(name = 'V3D') {
                let s = name + '(' + this.x.toFixed(2) + ', ' + this.y.toFixed(2) + ', ' + this.z.toFixed(2) + ')';
                return s;

            }
            toRGB() {
                let s = '#' + Math.trunc(this.x).toString(16).padStart(2, '0') + Math.trunc(this.y).toString(16).padStart(2, '0') + Math.trunc(this.z).toString(16).padStart(2, '0');
                return s;
            }
        }
        class NAtype {
            // Hesse normal form. Can be a plane or a line
            // plane: n (x-a) = 0
            // line: x(l) = l*n + a
            constructor(n, a) {
                this.n = n;   // nota: |n| = 1
                this.a = a;   // a point in the plane / line
                this.l = 0;   // l = lambda used to indicate whether a line intersects a plane in the direction of the normal vector of the line
                this.error = false;
            }
            toString(name = 'NAtype') {
                let s = name + '[n=' + this.n.toString() + ', ' + this.a.toString() + ']';
                return s;

            }
            distance(q) {
                // plane: distance to point
                // with sign: positive if the point is in the direction of the normal vector n
                //let delta = new V3Dtype;
                //delta.copy(this.a);
                let delta = this.a.clone();
                delta.subtract(q);
                return delta.sproduct(this.n);
            }
            x(l) {
                // line: a point on the line where distance between a and x is l
                let x = this.n.clone();
                x.mul(l);
                x.add(this.a);
                return x;
            }
            intersection_point(line) {
                let cos_g = this.n.sproduct(line.n) / 1 / 1;
                let a = this.a.clone();
                a.subtract(line.a);
                this.l = this.n.sproduct(a) / cos_g;
                return line.x(this.l);
            }
            screen_coordinates(p0x, p0y, n) {
                let s2 = this.intersection_point(new NAtype(n, new V3Dtype(0, 0, 0)));
                let s2x = -p0x.distance(s2);
                let s2y = p0y.distance(s2);
                this.error = false;
                if (this.l < 0) {
                    this.error = true;
                }
                if (Math.abs(this.l) > 10000) {
                    this.error = true;
                }
                return new V3Dtype(s2x, s2y, 0);
            }
            screen_coordinates2(p0x, p0y, n) {
                let s2 = this.intersection_point(new NAtype(n, new V3Dtype(0, 0, 0)));
                let s2x = -p0x.distance(s2);
                let s2y = p0y.distance(s2);
                this.error = false;
                if (this.l < 0) {
                    this.error = true;
                }
                if (Math.abs(this.l) > 10000) {
                    this.error = true;
                }
                return new V3Dtype(this.cwidth / 2 + s2x * this.magnification, this.cheight / 2 + s2y * this.magnification, 0);
            }
        }
        class M3Dtype
        {
            constructor(ax = 0, ay = 0, az = 0, bx = 0, by = 0, bz = 0, cx = 0, cy = 0, cz = 0) {
                this.ax = ax;
                this.ay = ay;
                this.az = az;
                this.bx = bx;
                this.by = by;
                this.bz = bz;
                this.cx = cx;
                this.cy = cy;
                this.cz = cz;
            }
            create_rot_n(n, a) {
                // rotate by a around normal vector n
                this.ax = n.x * n.x * (1 - Math.cos(a)) + Math.cos(a);
                this.ay = n.y * n.x * (1 - Math.cos(a)) + n.z * Math.sin(a);
                this.az = n.z * n.x * (1 - Math.cos(a)) - n.y * Math.sin(a);
                //
                this.bx = n.x * n.y * (1 - Math.cos(a)) - n.z * Math.sin(a);
                this.by = n.y * n.y * (1 - Math.cos(a)) + Math.cos(a);
                this.bz = n.z * n.y * (1 - Math.cos(a)) + n.x * Math.sin(a);
                //
                this.cx = n.x * n.z * (1 - Math.cos(a)) + n.y * Math.sin(a);
                this.cy = n.y * n.z * (1 - Math.cos(a)) - n.x * Math.sin(a);
                this.cz = n.z * n.z * (1 - Math.cos(a)) + Math.cos(a);
            }
            create_rot_z(a) {
                ax = Math.cos(a);
                ay = Math.sin(a);
                az = 0;
                bx = -Math.sin(a);
                by = Math.cos(a);
                bz = 0;
                cx = 0;
                cy = 0;
                cz = 1;
            }
            mmul(p) {
                return new V3Dtype(this.ax * p.x + this.bx * p.y + this.cx * p.z, this.ay * p.x + this.by * p.y + this.cy * p.z, this.az * p.x + this.bz * p.y + this.cz * p.z);
            }
            toString(name = "M3D") {
                s = "";
                s += name;
                s += "(";
                s += to_string(ax);
                s += ", ";
                s += to_string(bx);
                s += ", ";
                s += to_string(cx);
                s += ")";
                s += "\n";
                s += name;
                s += "(";
                s += to_string(ay);
                s += ", ";
                s += to_string(by);
                s += ", ";
                s += to_string(cy);
                s += ")";
                s += "\n";
                s += name;
                s += "(";
                s += to_string(az);
                s += ", ";
                s += to_string(bz);
                s += ", ";
                s += to_string(cz);
                s += ")";
                s += "\n";
                return s;
            }
        }
        // point of view
        var ego = new RADEtype(5, 0, 0, 0);
        var egoP = new RADEtype(0, 0, 90, 0);
        var e = ego.toV3D();
        var eP = egoP.toV3D();
        //var magnification = 600;
        var show_grid = true;
        var show_names = true;
        var rot_deg = 5;
        /*
        {
            for (i = 0; i < 360; i += 5) {
                let i1 = new RADEtype(i / 360 * 24, 0, 0, 0);
                let i2 = i1.toV3D();
                let i3 = i2.toRADE();
                console.log(i1.toString('RADE') + i2.toString('xy') + i3.toString('RADE'));
            }
        }
        */
        {
            let n = new V3Dtype(0.99, 0.13, 0.06);
            let rade = n.toRADE();
            console.log(rade.toString());
        }

        function RADEtoV3D(rade) {
            let a = new V3Dtype;
            //r = cos();
            return a;
        }
        function get_star_radius(mag) {
            /*
            let r = 1;
            if (mag < 2) r = 1;
            if (mag < 1) r = 2;
            if (mag < 0) r = 3;
            if (mag < -1) r = 4;
            */
            let ulux = 1e8 * Math.pow(10, -0.4 * (mag + 14.2));
            let r = Math.sqrt(ulux / Math.PI);
            return r;
        }
        {
            for (let i = -2; i < 7; ++i) {
                console.log(i.toFixed(1) + ' => ' + get_star_radius(i).toFixed(2))
            }
        }
        function getRGB(color, mag) {
            let rgb = 0;
            switch (color.charAt()) {
                case 'O': rgb = new V3Dtype(100, 100, 255); break;
                case 'B': rgb = new V3Dtype(150, 150, 255); break;
                case 'A': rgb = new V3Dtype(220, 220, 255); break;
                case 'F': rgb = new V3Dtype(255, 255, 220); break;
                case 'G': rgb = new V3Dtype(255, 255, 100); break;
                case 'K': rgb = new V3Dtype(255, 127, 100); break;
                case 'M': rgb = new V3Dtype(255, 100, 64); break;
                default: rgb = new V3Dtype(200, 200, 200); break;
            }
            if (mag > 4) rgb.mul(.7);
            if (mag > 5) rgb.mul(.6);
            if (mag > 6) rgb.mul(.6);
            let s = rgb.toRGB();
            return s;
        }
        function draw_star(ctx, mag, color, x, y) {
            //let ulux = 1e8 * Math.pow(10, -0.4 * (mag + 14.2));
            let sz = get_star_radius(mag);
            ctx.fillStyle = getRGB(color, mag);
            ctx.beginPath();
            ctx.arc(x, y, sz, 0, 2 * Math.PI);
            ctx.fill();
        }
        function draw_line(ctx, mag, color, x0, y0, x1, y1) {
            let sz = get_star_radius(mag);
            ctx.strokeStyle = getRGB(color, mag);
            // Start a new Path
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            // Draw the Path
            ctx.stroke();
        }
        var p0x = 0;
        var p0y = 0;
        var screen = new SCREENtype(new NAtype(e, e), cwidth, cheight, 600);
        function draw_line_on_screen(ctx, p1, p2, mag, color) {
            let s1c = p1.toV3D();
            let s2c = p2.toV3D();
            let s1 = screen.na.screen_coordinates(p0x, p0y, s1c);
            if (screen.na.error) return;
            let s2 = screen.na.screen_coordinates(p0x, p0y, s2c);
            if (screen.na.error) return;
            stest = s1.clone();
            stest.subtract(s2);
            /*
            if (stest.abs() > 1000) {
                console.log(stest.toString("overflow"))
                p2.toV3D();
            }
            */
            draw_line(ctx, mag, color, cwidth / 2 + s1.x * screen.magnification, cheight / 2 + s1.y * screen.magnification, cwidth / 2 + s2.x * screen.magnification, cheight / 2 + s2.y * screen.magnification);
        }
        function draw_star_on_screen(ctx, p1, mag, color) {
            let s1c = p1.toV3D();
            let s1 = screen.na.screen_coordinates(p0x, p0y, s1c);
            if (screen.na.error) return;
            draw_star(ctx, mag, color, cwidth / 2 + s1.x * screen.magnification, cheight / 2 + s1.y * screen.magnification);
        }
        function draw_text_on_screen(ctx, p1, mag, color, text, magStar) {
            let s1c = p1.toV3D();
            let s1 = screen.na.screen_coordinates(p0x, p0y, s1c);
            if (screen.na.error) return;
            //draw_star(ctx, mag, color, cwidth / 2 + s1.x * screen.magnification, cheight / 2 + s1.y * screen.magnification);
            let sz = get_star_radius(mag);
            ctx.fillStyle = getRGB(color, magStar);
            ctx.font = '12px georgia';
            ctx.textAlign = "left";
            ctx.textBaseline = 'top'
            ctx.fillText(text, cwidth / 2 + s1.x * screen.magnification + sz, cheight / 2 + s1.y * screen.magnification + sz);
        }
        function draw_field(ctx) {
            // fill with background color
            ctx.fillStyle = 'rgb(5, 5, 25)';
            ctx.fillRect(0, 0, cwidth, cheight);
            // text
            ctx.fillStyle = 'blue';
            ctx.font = '24px georgia';
            p0x = new NAtype(e.xproduct(eP), e);
            p0y = new NAtype(eP, new V3Dtype(0, 0, 0));
            screen.na = new NAtype(e, e);
            if (show_grid) {
                // draw north pole
                {
                    draw_line_on_screen(ctx, new RADEtype(0, 0, 88, 0), new RADEtype(12, 0, 88, 0), 6, "G2");
                    draw_line_on_screen(ctx, new RADEtype(6, 0, 88, 0), new RADEtype(18, 0, 88, 0), 6, "G2");
                    draw_text_on_screen(ctx, new RADEtype(0, 0, 90, 0), 1, "G2", "North Pole", 6);
                    /*
                    // color test
                    draw_star_on_screen(ctx, new RADEtype(5, 0, 0, 0), -2, "O");
                    draw_star_on_screen(ctx, new RADEtype(5, 200, 0, 0), -2, "B");
                    draw_star_on_screen(ctx, new RADEtype(5, 400, 0, 0), -2, "A");
                    draw_star_on_screen(ctx, new RADEtype(6, 0, 0, 0), -2, "F");
                    draw_star_on_screen(ctx, new RADEtype(6, 200, 0, 0), -2, "G");
                    draw_star_on_screen(ctx, new RADEtype(6, 400, 0, 0), -2, "K");
                    draw_star_on_screen(ctx, new RADEtype(7, 0, 0, 0), -2, "M");
                    */
                }
                // draw south pole
                {
                    draw_line_on_screen(ctx, new RADEtype(0, 0, -88, 0), new RADEtype(12, 0, -88, 0), 6, "G2");
                    draw_line_on_screen(ctx, new RADEtype(6, 0, -88, 0), new RADEtype(18, 0, -88, 0), 6, "G2");
                    draw_text_on_screen(ctx, new RADEtype(0, 0, -90, 0), 1, "G2", "South Pole", 6);
                }
                // draw equator and wendekreise
                for (let i = 0; i < 360; i += 2) {
                    const ecliptic_obliquity = 23.4; // degrees
                    const polar_de = 66.5; // degrees
                    draw_line_on_screen(ctx, new RADEtype(i / 15, 0, 0, 0), new RADEtype((i + 1) / 15, 0, 0, 0), 6, "G2");
                    draw_line_on_screen(ctx, new RADEtype(i / 15, 0, ecliptic_obliquity, 0), new RADEtype((i + 1) / 15, 0, ecliptic_obliquity, 0), 6, "G2");
                    draw_line_on_screen(ctx, new RADEtype(i / 15, 0, -ecliptic_obliquity, 0), new RADEtype((i + 1) / 15, 0, -ecliptic_obliquity, 0), 6, "G2");
                    draw_line_on_screen(ctx, new RADEtype(i / 15, 0, polar_de, 0), new RADEtype((i + 1) / 15, 0, polar_de, 0), 6, "B2");
                    draw_line_on_screen(ctx, new RADEtype(i / 15, 0, -polar_de, 0), new RADEtype((i + 1) / 15, 0, -polar_de, 0), 6, "B2");
                }
                // draw ecliptic
                {
                    // North: right ascension 18h 0m 0.0s (exact), declination +66° 33′ 38.55″
                    let eclipticRADE = new RADEtype(18, 0, 66, 34);
                    let eclipticN = eclipticRADE.toV3D();
                    let springRADE = new RADEtype(0, 0, 0, 0);
                    let pos0 = springRADE.toV3D();
                    let rot2deg = new M3Dtype();
                    rot2deg.create_rot_n(eclipticN, 1 * Math.PI / 180);
                    for (let i = 0; i < 360; i += 2) {
                        let pos1 = rot2deg.mmul(pos0);
                        let pos0RADE = pos0.toRADE();
                        let pos1RADE = pos1.toRADE();
                        //console.log(pos0RADE.toString() + ' ' + pos0.toString() + ' => ' + pos1RADE.toString() + ' ' + pos1.toString());
                        draw_line_on_screen(ctx, pos0RADE, pos1RADE, 6, "G2");
                        pos0 = rot2deg.mmul(pos1);
                    }
                    draw_text_on_screen(ctx, new RADEtype(0, 0, 0, 0), 1, "G2", "Frühlingspunkt", 6);
                    draw_text_on_screen(ctx, new RADEtype(12, 0, 0, 0), 1, "G2", "Herbstpunkt", 6);
                    draw_line_on_screen(ctx, new RADEtype(6, 0, 1, 0), new RADEtype(6, 0, -1, 0), 6, "G2");
                    draw_text_on_screen(ctx, new RADEtype(6, 0, 0, 0), 1, "G2", "Sommersonnenwende", 6);
                    draw_line_on_screen(ctx, new RADEtype(18, 0, 1, 0), new RADEtype(18, 0, -1, 0), 6, "G2");
                    draw_text_on_screen(ctx, new RADEtype(18, 0, 0, 0), 1, "G2", "Wintersonnenwende", 6);
                }
                // draw 0 and 12 meridian
                for (let i = -90; i < 90; i += 2) {
                    draw_line_on_screen(ctx, new RADEtype(0, 0, i, 0), new RADEtype(0, 0, i + 1, 0), 6, "G2");
                    draw_line_on_screen(ctx, new RADEtype(12, 0, i, 0), new RADEtype(12, 0, i + 1, 0), 6, "G2");
                }
            }
            // draw stars
            let cnt = 0;
            for (let i = 0; i < stars.length; ++i) {
                cnt++;
                //if (stars[i].h > 12) continue;
                let starRADE = new RADEtype(stars[i].h, stars[i].dm, stars[i].d, stars[i].m);
                let starpoint = starRADE.toV3D();
                /*
                let l = 0;
                let s3 = screen.na.screen_coordinates(p0x, p0y, starpoint);
                if (screen.na.error) continue;
                */
                draw_star_on_screen(ctx, starRADE, stars[i].Ptm, stars[i].SpT);
                if (show_names && stars[i].name.length && stars[i].Ptm < 2.5) {
                    draw_text_on_screen(ctx, starRADE, stars[i].Ptm, stars[i].SpT, stars[i].name, 6);
                }
            }
            // inscription
            text2.innerHTML = "<h2>"
                + "Position: " + ego.toString('View') + "<br>"
                + 'Stars: ' + cnt.toString() + "<br>"
                + "Keys:" + "<br>"
                + "<-    yaw left" + "<br>"
                + "->    yaw right" + "<br>"
                + "up    pitch up" + "<br>"
                + "down  pitch down" + "<br>"
                + "L     roll left" + "<br>"
                + "R     roll right" + "<br>"
                + "N     switch star names on/off" + "<br>"
                + "G     switch grid on/off" + "<br>"
                ;
            /*
            ctx.fillStyle = 'orange';
            ctx.fillText(ego.toString('View')
                + ', stars=' + cnt.toString()
                , 0, 50);
                */
        }

        const st_insertcoin = 0;
        const st_playing = 1;
        const st_gameover = 2;
        var status = st_insertcoin;
        function loop() {
            const ctx = canvas.getContext('2d');
            if (status == st_insertcoin) {
                //process event:
                switch (eventq) {
                    case 32:
                    case 13:
                        Tetris.play();
                        status = st_playing;
                        break;
                }
                eventq = 0;
                // fill with background color
                ctx.fillStyle = 'rgb(5, 5, 25)';
                ctx.fillRect(0, 0, cwidth, cheight);
                // text
                ctx.fillStyle = 'blue';
                ctx.font = '128px georgia';
                ctx.fillText('STARS', 100, 100);
                ctx.font = '48px georgia';
                ctx.fillText('Press SPACE to start', 100, 200);
            }
            else if (status == st_gameover) {
                //process event:
                switch (eventq) {
                    case 32:
                    case 13:
                        Flick.play();
                        status = st_insertcoin;
                        break;
                }
                eventq = 0;
                // fill with background color
                ctx.fillStyle = 'rgb(255, 255, 255)';
                ctx.fillRect(0, 0, cwidth, cheight);
                // draw
                draw_field(ctx);
                // text
                ctx.fillStyle = 'red';
                ctx.font = '64px georgia bold';
                ctx.fillText('GAME OVER', getox(0), getoy(height / 2 - 2));
                ctx.font = '48px georgia';
                ctx.fillText('Press SPACE', getox(0), getoy(height / 2));
            }
            else if (status == st_playing) {
                //process event:
                switch (eventq) {
                    case 37:
                        //yaw left
                        {
                            // eP is the yaw axis
                            let m = new M3Dtype();
                            m.create_rot_n(eP, rot_deg * Math.PI / 180);
                            e = m.mmul(e);
                            eP = m.mmul(eP);
                            ego = e.toRADE();
                        }
                        break;
                    case 39:
                        //yaw right
                        {
                            // eP is the yaw axis
                            let m = new M3Dtype();
                            m.create_rot_n(eP, -rot_deg * Math.PI / 180);
                            e = m.mmul(e);
                            eP = m.mmul(eP);
                            ego = e.toRADE();
                        }
                        break;
                    case 38:
                        //pitch up
                        {
                            let a = e.xproduct(eP)
                            // a is the pitch axis
                            let m = new M3Dtype();
                            m.create_rot_n(a, rot_deg * Math.PI / 180);
                            e = m.mmul(e);
                            eP = m.mmul(eP);
                            ego = e.toRADE();
                        }
                        break;
                    case 40:
                        //pitch down
                        {
                            let a = e.xproduct(eP)
                            // a is the pitch axis
                            let m = new M3Dtype();
                            m.create_rot_n(a, -rot_deg * Math.PI / 180);
                            e = m.mmul(e);
                            eP = m.mmul(eP);
                            ego = e.toRADE();
                        }
                        break;
                    case 71: // 'G':
                        show_grid = !show_grid;
                        break;
                    case 78: // 'N':
                        show_names = !show_names;
                        break;
                    case 76: // 'L'
                        //roll left
                        {
                            // e is the roll axis
                            let m = new M3Dtype();
                            m.create_rot_n(e, rot_deg * Math.PI / 180);
                            e = m.mmul(e);
                            eP = m.mmul(eP);
                            ego = e.toRADE();
                        }
                        break;
                    case 82: 
                        //roll right
                        {
                            // e is the roll axis
                            let m = new M3Dtype();
                            m.create_rot_n(e, -rot_deg * Math.PI / 180);
                            e = m.mmul(e);
                            eP = m.mmul(eP);
                            ego = e.toRADE();
                        }
                        break;
                    case 32:
                        //space
                        break;
                    case 107: //num +
                    case 187: //keyboard+
                        // plus
                        screen.magnification *= 1.2;
                        break;
                    case 109: //num-
                    case 189: //keyboard-
                        //minus
                        screen.magnification /= 1.2;
                        break;
                }
                eventq = 0;
                // draw
                draw_field(ctx);
            }
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>